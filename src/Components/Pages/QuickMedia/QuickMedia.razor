@page "/quickmedia"
@using Iot.Device.GoPiGo3.Sensors
@using System.Threading.Tasks
@using WearWare.Services.Library
@using WearWare.Services.QuickMedia
@using WearWare.Components.Pages.Shared.PlaylistItem
@using WearWare.Common.Media
@rendermode InteractiveServer

@inject QuickMediaService QuickMediaService
@inject WearWare.Services.Library.LibraryService LibraryService
@inject IJSRuntime JSRuntime
@inject WearWare.Services.StreamConverter.IStreamConverterService StreamConverterService

@code {
    // ================================================== Common ==================================================
    private IReadOnlyList<IQuickMediaButton?> quickButtons = Array.Empty<IQuickMediaButton?>();
    private IReadOnlyList<PlayableItem>? libraryItems;

    protected override void OnInitialized()
    {
        try
        {
            quickButtons = QuickMediaService?.GetQuickMediaButtons() ?? Array.Empty<IQuickMediaButton?>();
        }
        catch
        {
            quickButtons = Array.Empty<IQuickMediaButton?>();
        }
        libraryItems = LibraryService.Items;
        if (QuickMediaService != null)
            QuickMediaService.StateChanged += OnStateChanged;
    }

    /// <summary>
    /// Handler for QuickMediaService StateChanged event.
    /// Currently, this is not used for anything (See notes in the Service)
    /// It's OK to remove the subscription, but do not remove the event itself from the service as the Mock page uses it.
    /// </summary>
    private void OnStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        if (QuickMediaService != null)
            QuickMediaService.StateChanged -= OnStateChanged;
    }



    // ================================================== Add Dialog  ==================================================
    private bool showAddDialog = false;
    private int addDialogInsertIndex = 0;
    private AddPlayableItemForm? addFormRef;

    void OnAddDialogShow(int index)
    {
        addDialogInsertIndex = index;
        showAddDialog = true;
    }

    void OnAddDialogCancel()
    {
        showAddDialog = false;
        StateHasChanged();
    }

    /// <summary>
    /// Called after we click "Add" and a playable item is picked from the list
    /// </summary>
    /// <param name="args"></param> Tuple of (insertIndex, libItem)
    async Task OnAddDialogItemChosen((int insertIndex, PlayableItem libItem) args)
    {
        @* QuickMediaService.AddQuickMediaButton(args.insertIndex, args.libItem); *@
        showAddDialog = false;
        await InvokeAsync(StateHasChanged);
        if (addFormRef is not null)
            await addFormRef.UnlockScrollAsync();
        await OnEditQuickMediaItem(args.libItem, args.insertIndex, PlayableItemFormMode.ADD);
    }

    // ================================================== Edit Dialog  ==================================================
    private Boolean showEditDialog = false;
    private int editingIndex = -1;
    private PlayableItem? editingItem = null;
    private PlayableItem? _originalItem;
    // ToDo: Can we not remove this?
    @* private IQuickMediaButton? editingButton = null; *@
    private EditPlayableItemForm? editFormRef;

    /// <summary>
    /// The mode of the EditPlayableItemForm
    /// Not used by the form itself, but when it returns we can know if we were adding or editing
    /// </summary>
    private PlayableItemFormMode formMode;

    /// <summary>
    /// Called when Edit is clicked on the QuickMedia page
    /// </summary>
    /// <param name="button"></param>
    /// <param name="index"></param>
    async Task OnEditQuickMediaItem(PlayableItem item, int index, PlayableItemFormMode mode)
    {
        editingIndex = index;
        _originalItem = item;
        editingItem = item.Clone();
        if (mode == PlayableItemFormMode.ADD)
        {
            // In Add mode, the item being passed in is from the library, so we need to modify some properties.
            // We need to do this BEFORE opening the Edit form so that the form shows the correct values.
            // DO NOT modify ParentFolder at this point - the Service will need this to get the source file from the library
            // Set PlayMode to LOOP and PlayModeValue to 1 by default...
            // ... because library items have FOREVER mode by default
            editingItem.PlayMode = PlayMode.LOOP;
            editingItem.PlayModeValue = 1;
        }
        @* editingButton = button; *@
        formMode = mode;
        showEditDialog = true;
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Called when Save is clicked in the EditPlayableItemForm
    /// </summary>
    /// <param name="args"></param>
    /// <returns></returns>
    public async Task OnSaveQuickMediaItem((int editingIndex, PlayableItem item, PlayableItemFormMode formMode) args)
    {
        if (editingItem is null || _originalItem is null || editingIndex < 0) return; // ToDo: Error handling
        await QuickMediaService.OnEditFormSubmit(editingIndex, _originalItem, args.item, args.formMode);
        showEditDialog = false;
        editingItem = null;
        _originalItem = null;
        await InvokeAsync(StateHasChanged);
        if (editFormRef is not null)
            await editFormRef.UnlockScrollAsync();
    }

    /// <summary>
    /// Hides the Edit Item dialog - called on Cancel
    /// </summary>
    async Task HideEditDialog()
    {
        showEditDialog = false;
        editingItem = null;
        _originalItem = null;
        await InvokeAsync(StateHasChanged);
        if (editFormRef is not null)
            await editFormRef.UnlockScrollAsync();

    }

    /// <summary>
    /// Called to reprocess (re-convert) the quickmedia button's item with new options
    /// </summary>
    /// <param name="options"></param>
    /// <param name="relativeBrightness"></param>
    /// <returns></returns>
    /// ToDo: Needs to be removed - Reprocessing should be handled by the Service instead.
    /// Once removed, also remove:
    /// - OnReprocessAsync parameter from EditPlayableItemForm in this page.
    /// - OnReprocessAsync parameter from EditPlayableItemForm.razor
    private async Task<WearWare.Common.ReConvertTaskResult> ReprocessQuickMediaButtonAsync(WearWare.Services.MatrixConfig.LedMatrixOptionsConfig? options, int relativeBrightness)
    {
        if (editingIndex < 0)
        {
            return new WearWare.Common.ReConvertTaskResult { ExitCode = -1, Error = "Invalid", Message = "No quickmedia selected", ActualBrightness = 0 };
        }
        var btn = quickButtons.ElementAtOrDefault(editingIndex);
        if (btn?.Item is null)
        {
            return new WearWare.Common.ReConvertTaskResult { ExitCode = -1, Error = "Invalid", Message = "Selected quickmedia button has no item", ActualBrightness = 0 };
        }
        try
        {
            var folder = System.IO.Path.Combine(WearWare.Config.PathConfig.QuickMediaPath, editingIndex.ToString());
            return await StreamConverterService.ConvertToStream(folder, btn.Item.SourceFileName, folder, btn.Item.Name, relativeBrightness, options);
        }
        catch (Exception ex)
        {
            return new WearWare.Common.ReConvertTaskResult { ExitCode = -1, Error = ex.Message, Message = "ReConvert failed", ActualBrightness = 0 };
        }
    }
    // ================================================= Delete Item ==================================================
    void DeleteQuickMediaButton(int index)
    {
        QuickMediaService.DeleteQuickMediaButton(index);
        StateHasChanged();
    }

    private async Task ConfirmDeleteQuickMediaButton(int index)
    {
        var btn = quickButtons.ElementAtOrDefault(index);
        var name = btn?.Item?.Name ?? $"Button {index+1}";
        var ok = await JSRuntime.InvokeAsync<bool>("confirm", $"Delete quick-media button '{name}'?");
        if (ok)
        {
            DeleteQuickMediaButton(index);
        }
    }
}

<PageTitle>Quick Media</PageTitle>

@if (quickButtons is null || quickButtons.Count == 0)
{
	<p>No quick-media buttons available.</p>
}
else
{
	<div class="qm-button-list">
		@for (int i = 0; i < quickButtons.Count; i++)
		{
			var btn = quickButtons[i];
			var index = i;  // Need to preserve index for lambda capture, else lambda always gets last value of i
			<div class="qm-button-item">
				<span class="qm-button-title">B@(i + 1)</span>
				<div class="qm-item-controls">
					@if (btn is null)
					{
						<button class="btn btn-sm btn-outline-primary" @onclick="() => OnAddDialogShow(index)">Add</button>
					}
					else
					{
						<button class="btn btn-sm btn-outline-primary" @onclick="() => OnEditQuickMediaItem(btn.Item, index, PlayableItemFormMode.EDIT)">Edit</button>
					}
                    @if (btn?.Item is not null)
                    {
                        <button class="btn btn-sm btn-outline-danger" @onclick="() => ConfirmDeleteQuickMediaButton(index)">Delete</button>
                    }
				</div>
				@if (btn?.Item is not null)
				{
					<PlaylistItem ImageSrc="@($"/quickmedia-images/{index}/{btn.Item.SourceFileName}")" Item="btn.Item" />
				}
			</div>
		}
	</div>
}

@if (showAddDialog)
{
	<AddPlayableItemForm 
		@ref="addFormRef"
		LibraryItems="libraryItems"
		InsertIndex="addDialogInsertIndex"
		PageTitle="@($"QuickMedia Button {addDialogInsertIndex+1}")"
		OnCancel="OnAddDialogCancel"
		OnAdd="OnAddDialogItemChosen" />
}

@if (showEditDialog && editingItem is not null)
{
    <EditPlayableItemForm
        @ref="editFormRef"
        EditingItem="editingItem"
        EditingIndex="editingIndex"
        ImageUrl="@($"/quickmedia-images/{editingIndex}/{editingItem.SourceFileName}")"
        OnCancel="HideEditDialog"
        OnSave="OnSaveQuickMediaItem"
        OnReprocessAsync="ReprocessQuickMediaButtonAsync"
        ItemType="PlayableItemType.QUICKMEDIA"
        FormMode="formMode"
    />
}
