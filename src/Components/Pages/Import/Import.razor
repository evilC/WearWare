@page "/import"
@using System.Threading.Tasks
@using WearWare.Config
@using static WearWare.Common.Media.MediaTypeMappings
@using static WearWare.Common.Media.MediaType
@using WearWare.Common.Media
@using WearWare.Common
@using Microsoft.AspNetCore.Components.Forms
@using WearWare.Utils
@rendermode InteractiveServer
@inject WearWare.Services.Import.ImportService ImportService
@inject WearWare.Services.MatrixConfig.MatrixConfigService MatrixConfigService
@inject IJSRuntime JSRuntime
@inject HttpClient Http
@inject NavigationManager Navigation

<h3>Import</h3>

@if (showEditDialog && _editingItem != null && selectedFileName != null)
{
    <EditPlayableItemForm @ref="editFormRef" EditingItem="_editingItem" EditingIndex="0" ItemType="PlayableItemType.Import" FormMode="PlayableItemFormMode.Add" ImageUrl="@($"/incoming-media/{selectedFileName}")" OnSave="OnSaveImportItem" OnCancel="OnOptionsOk" />
}
else if (importFiles == null)
{
    <p>Loading images...</p>
}
else if (!importFiles.Any())
{
    <p>No images found in the incoming folder.</p>
}
else
{
    <div class="mb-3">
        <button type="button" class="btn btn-primary" @onclick="TriggerFileInput">Upload new file</button>
        <InputFile id="@inputId" style="display:none;" OnChange="HandleFileSelected" />
    </div>
    <ul class="import-list" style="list-style:none; padding:0; margin:0;">
        @foreach (var file in importFiles)
        {
            <li style="margin-bottom:2em; display:flex; align-items:center; gap:0.5em; cursor:pointer;"
                @onclick="() => ShowForm(file)">
                <div style="display:flex; flex-direction:column; gap:0.25em;">
                    <button type="button" class="btn btn-sm btn-outline-danger" @onclick="() => ConfirmDelete(file)" @onclick:stopPropagation="true">Delete</button>
                </div>
                <img src="/incoming-media/@file" alt="@file" style="max-width: 64px; max-height: 64px; display: block;" />
                <div>
                    <strong style="font-size:1em; color:#222;">@file</strong><br />
                </div>
            </li>
        }
    </ul>
}

@code {
    private List<string>? importFiles;
    private string? selectedFileName;
    private bool showEditDialog = false;
    private string? pendingNewFileName;
    
    private PlayableItem? _editingItem;
    private EditPlayableItemForm? editFormRef;
    private string inputId = "fileInput_" + System.Guid.NewGuid().ToString("N");

    protected override void OnInitialized()
    {
        importFiles = ImportService.GetImportFiles();
        ImportService.StateChanged += OnStateChanged;
    }

    private void OnStateChanged()
    {
        importFiles = ImportService.GetImportFiles();
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        ImportService.StateChanged -= OnStateChanged;
    }

    private async Task ShowForm(string fileName)
    {
        selectedFileName = fileName;
        // Prepare an editing PlayableItem immediately (ImportForm UI moved into EditPlayableItemForm)
        var mediaType = MediaTypeMappings.GetMediaType(Path.GetExtension(selectedFileName)) ?? MediaType.IMAGE;
        var baseName = Path.GetFileNameWithoutExtension(selectedFileName);
        var sanitized = FilenameValidator.Sanitize(baseName);
        var baseBrightness = MatrixConfigService.CloneOptions().Brightness ?? 100;
        var actual = BrightnessCalculator.CalculateAbsoluteBrightness(baseBrightness, 100);
        _editingItem = new PlayableItem(
            sanitized,
            PathConfig.LibraryFolder,
            mediaType,
            selectedFileName,
            PlayMode.FOREVER,
            1,
            100,
            actual,
            MatrixConfigService.CloneOptions()
        );
        pendingNewFileName = sanitized;
        showEditDialog = true;
        await InvokeAsync(StateHasChanged);
    }

    private async Task ConfirmDelete(string fileName)
    {
        var ok = await JSRuntime.InvokeAsync<bool>("confirm", $"Delete incoming file '{fileName}'?");
        if (ok)
        {
            ImportService.DeleteIncomingFile(fileName);
        }
    }

    // ImportForm removed; ShowForm() now creates the editing item directly.

    private async Task OnSaveImportItem((int editingIndex, PlayableItem updatedItem, PlayableItemFormMode formMode) args)
    {
        showEditDialog = false;
        if (pendingNewFileName != null && selectedFileName != null)
        {
            await ImportService.OnEditFormSubmit(selectedFileName, args.updatedItem.Name, args.updatedItem.RelativeBrightness, args.updatedItem.MatrixOptions);
        }
        // clear state
        pendingNewFileName = null;
        selectedFileName = null;
        _editingItem = null;
        if (editFormRef is not null)
            await editFormRef.UnlockScrollAsync();
        await InvokeAsync(StateHasChanged);
    }

    private Task OnOptionsOk()
    {
        // Close the edit form and return to the import list without importing
        showEditDialog = false;
        pendingNewFileName = null;
        selectedFileName = null;
        _editingItem = null;
        return Task.CompletedTask;
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null)
            return;

        var content = new MultipartFormDataContent();
        var stream = file.OpenReadStream(long.MaxValue);
        var streamContent = new StreamContent(stream);
        streamContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType ?? "application/octet-stream");
        content.Add(streamContent, "file", file.Name);

        try
        {
            var uploadUrl = Navigation.BaseUri.TrimEnd('/') + "/incoming-media/upload";
            var resp = await Http.PostAsync(uploadUrl, content);
            if (!resp.IsSuccessStatusCode)
            {
                var msg = await resp.Content.ReadAsStringAsync();
                await JSRuntime.InvokeVoidAsync("alert", $"Upload failed: {msg}");
            }
            else
            {
                // Refresh local list (endpoint will also notify ImportService)
                importFiles = ImportService.GetImportFiles();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Upload error: {ex.Message}");
        }
    }

    private async Task TriggerFileInput()
    {
        // Use a small eval to click the hidden file input by id
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", $"document.getElementById('{inputId}').click();");
        }
        catch
        {
            // Ignore JS errors
        }
    }
}
